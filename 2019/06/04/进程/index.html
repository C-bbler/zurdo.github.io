<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh_CH">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Linux,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="进程程序 存放在磁盘中的指令和数据的有序集合。 是静态的。">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="进程">
<meta property="og:url" content="http://yoursite.com/2019/06/04/进程/index.html">
<meta property="og:site_name" content="Zurdo">
<meta property="og:description" content="进程程序 存放在磁盘中的指令和数据的有序集合。 是静态的。">
<meta property="og:locale" content="zh_CH">
<meta property="og:image" content="http://yoursite.com/2019/06/04/进程/%E8%BF%9B%E7%A8%8B.png">
<meta property="og:image" content="http://yoursite.com/2019/06/04/进程/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png">
<meta property="og:image" content="http://yoursite.com/2019/06/04/进程/%E4%BD%9C%E4%B8%9A%E5%8F%B7.png">
<meta property="og:image" content="http://yoursite.com/2019/06/04/进程/pipe.jpg">
<meta property="og:image" content="http://yoursite.com/2019/06/04/进程/%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86.png">
<meta property="og:updated_time" content="2019-10-10T14:14:52.443Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="进程">
<meta name="twitter:description" content="进程程序 存放在磁盘中的指令和数据的有序集合。 是静态的。">
<meta name="twitter:image" content="http://yoursite.com/2019/06/04/进程/%E8%BF%9B%E7%A8%8B.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/06/04/进程/">





  <title> 进程 | Zurdo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh_CH">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zurdo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/04/进程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zurdo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zurdo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                进程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-04T19:23:01+08:00">
                2019-06-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><ol>
<li>存放在磁盘中的指令和数据的有序集合。</li>
<li>是静态的。</li>
</ol>
<a id="more"></a>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ol>
<li>执行程序时系统分配的所有资源的总称。</li>
<li>进程是程序的一次执行过程。</li>
<li>进程是动态的，包括创建、调度、执行、消亡。</li>
</ol>
<p><img src="/2019/06/04/进程/%E8%BF%9B%E7%A8%8B.png" alt="图片"></p>
<p>进程控制块（PCb）包括以下几个部分：</p>
<ol>
<li>进程标识（PID）</li>
<li>进程用户（由哪个用户创建）</li>
<li>进程的状态、优先级</li>
<li>文件描述符（记录当前进程打开了哪些文件）</li>
</ol>
<h4 id="进程的类型"><a href="#进程的类型" class="headerlink" title="进程的类型"></a>进程的类型</h4><ol>
<li>交互类型</li>
<li>批处理进程</li>
<li>守护进程</li>
</ol>
<p>①交互类型（前台进程：可以在终端输入/输出，后台进程：可以在终端输入，可以输出）在shell下启动，可以在前台运行，也可以在后台运行<br>②批处理进程   ： 和在终端无关，被提交到一个作业队列中以便顺序执行<br>③守护进程  ： 和终端无关，一直在后台运行</p>
<h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><ol>
<li>运行态：正在运行或者就绪态</li>
<li>等待态（阻塞态/睡眠态）：进程在等待一个实际按的发生或某种系统的释放<ol>
<li>可中断</li>
<li>不可中断</li>
</ol>
</li>
<li>停止态：进程被终止，收到信号后可以恢复运行</li>
<li>死亡态（僵尸态）：已中止的进程，但是pcb没有释放，其他资源都被释放（pcb存放的是进程的返回值和结束方式，这些信息必须由父进程回收处理）<br><img src="/2019/06/04/进程/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="图片"></li>
</ol>
<h4 id="Linux中查看进程信息"><a href="#Linux中查看进程信息" class="headerlink" title="Linux中查看进程信息"></a>Linux中查看进程信息</h4><ol>
<li>ps   查看系统进程快照<br>常用格式： <code>ps -ef|more</code>查看所有进程分页显示   <code>ps-ef|grep</code> 查找指定进程</li>
<li>top  查看进程的动态信息</li>
<li>/proc  查看进程的详细信息<br>使用格式：<code>cd /proc  进程号</code></li>
</ol>
<h4 id="进程的相关命令"><a href="#进程的相关命令" class="headerlink" title="进程的相关命令"></a>进程的相关命令</h4><ol>
<li>nice 指定数字（[-20,19]数字越小优先级越高，默认为0），来修改进程的优先级（普通用户指定的数字最小是0）<br> 命令格式：<code>nice -n 2 ./test</code></li>
<li>renice 改变一个已经在执行的进程优先级<br> 命令格式：<code>renice -n 2  进程号</code></li>
<li>jobs   查看终端上的后台进程</li>
<li>bg   让一个后台作业在后台运行（由停止态变为运行态）</li>
<li>fg  将后台运行的进程变为前台进程运行<br> 命令格式：<code>fg  作业号</code><br><img src="/2019/06/04/进程/%E4%BD%9C%E4%B8%9A%E5%8F%B7.png" alt="图片"></li>
<li>将正在运行的前台进程变为后台挂起<br>快捷键   ctrl + z</li>
</ol>
<hr>
<h3 id="进程的相关函数"><a href="#进程的相关函数" class="headerlink" title="进程的相关函数"></a>进程的相关函数</h3><h4 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h4><ol>
<li>子进程继承父进程的内容（代码，指令，数据….）</li>
<li>父子进程有独立的空间地址，互不影响</li>
<li>若父进程先结束<ol>
<li>子进程称为孤儿进程，被  init 进程 （内核启动后创建的第一个用户进程，进程号为1） 收养</li>
<li>子进程若在前台运行，自动变为后台进程</li>
</ol>
</li>
<li>若子进程先结束<ol>
<li>父进程没有及时回收，子进程变为僵尸进程</li>
</ol>
</li>
<li>子进程从fork函数后的第一条语句开始执行</li>
</ol>
<h4 id="进程的返回值和结束方式"><a href="#进程的返回值和结束方式" class="headerlink" title="进程的返回值和结束方式"></a>进程的返回值和结束方式</h4><ol>
<li>子进程通过_exit/exit/return 返回某个值（0~255）（正常结束）</li>
<li>父进程调用wait(&amp;status)回收 （非正常结束）<ol>
<li>WIFEXITED(status)         系统宏 ，判断子进程是否正常结束</li>
<li>WEXITSTATUS(status)    获取子进程的返回值</li>
<li>WIFSIGNLED(status)    判断子进程是否被信号结束</li>
<li>WTERMSIG (status)      获取子进程的信号类型<br>（status的低七位是0，表示正常结束；低七位是非0，表示是被信号结束的，并且低七位表示的是信号的类型）</li>
</ol>
</li>
</ol>
<h4 id="进程创建-fork"><a href="#进程创建-fork" class="headerlink" title="进程创建 - fork"></a>进程创建 - fork</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_d  fork(void);</span><br></pre></td></tr></table></figure>

<ol>
<li>创建新的进程，失败返回EOR</li>
<li>创建成功父进程返回子进程的进程号，子进程返回0</li>
<li>通过fork的返回值区分父子进程</li>
</ol>
<p>实例：创建一个子进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">	 pid_t pid;//函数的返回值类型</span><br><span class="line">	</span><br><span class="line">	 if((pid = fork())&lt;0)//创建失败</span><br><span class="line">	&#123;</span><br><span class="line">		 perror(&quot;fork&quot;);</span><br><span class="line">		 return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	//getpid();   获取进程号</span><br><span class="line">	 else if(pid == 0)//子进程</span><br><span class="line">	 &#123;</span><br><span class="line">	 	 printf(&quot;this child process\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	 else</span><br><span class="line">	 &#123;</span><br><span class="line">		  printf(&quot;this parent process\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	 return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="进程结束-exit-exit"><a href="#进程结束-exit-exit" class="headerlink" title="进程结束 - exit/_exit"></a>进程结束 - exit/_exit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include  &lt;stdlib.h&gt;</span><br><span class="line">void exit(int status);  //status是需要结束的进程号</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void _exit(int status);</span><br></pre></td></tr></table></figure>

<ol>
<li>exit(-1) 表示因为某些异常而结束进程</li>
<li>exit(0)  表示正常结束</li>
<li>exit()在结束进程的时候会刷新流的缓冲区，_exit()不刷新</li>
</ol>
<h4 id="进程-exec函数族"><a href="#进程-exec函数族" class="headerlink" title="进程 - exec函数族"></a>进程 - exec函数族</h4><p>(函数族的作用：在一个进程中启动一个新的进程)</p>
<ol>
<li><p>进程调用exec函数族执行某个程序</p>
</li>
<li><p>进程当前内容被指定的程序替换</p>
</li>
<li><p>实现让父子进程执行不同的程序</p>
<ol>
<li>父进程创建子进程</li>
<li>子进程调用exec函数族</li>
<li>父进程不受影响</li>
</ol>
</li>
<li><p>进程 - execl/execlp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int execl(const char *path,const char *arg,…..);</span><br><span class="line">int execlp(const char *file,const char *arg,…..);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>①path应该包含完整路径，可以是相对路径，也可以是绝对路径<br>②成功时执行指定的程序，失败返回EOR<br>③arg…  传递给程序的参数列表(类似于main函数传参)，最后一个参数必须为NULL<br>④file 执行的程序名称，在path中查找该程序<br>eg ：执行ls命令，显示etc目录下所有文件的详细信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(excel(&quot;/bin/ls&quot;,&quot;-a&quot;,&quot;-l&quot;,&quot;etc&quot;,NULL)&lt;0)</span><br><span class="line">	 perror(&quot;execl&quot;);</span><br><span class="line">if(excelp(&quot;ls&quot;,&quot;-a&quot;,&quot;-l&quot;,&quot;etc&quot;,NULL)&lt;0)</span><br><span class="line">		 perror(&quot;execlp&quot;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>进程 - execv/execvp<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> int execv(const char *path,const char *arg[]);</span><br><span class="line"> int execvp(const char *file,const char *arg[]);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>①成功执行指定程序，失败返回EOR<br>② arg.. 封装成指针数组的形式</p>
<p>eg ：执行ls命令，显示etc目录下所有文件的详细信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char *arg[] = &#123;&quot;ls&quot;,&quot;-a&quot;,&quot;-l&quot;,&quot;etc&quot;,NULL&#125;</span><br><span class="line">if(excev(&quot;/bin/ls&quot;,arg)&lt;0)</span><br><span class="line">	 perror(&quot;execv&quot;);</span><br><span class="line">if(excevp(&quot;ls&quot;,arg)&lt;0)</span><br><span class="line">	 perror(&quot;execvp&quot;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进程 - system<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int system(const char *command)；</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>①在当前进程中自动创建一个子进程，执行command所包含的程序<br>②父进程一直等待子进程执行完成，才继续向下执行程序(阻塞状态)<br>③成功执行返回command的返回值，失败返回EOR</p>
<h4 id="进程回收-wait"><a href="#进程回收-wait" class="headerlink" title="进程回收 - wait"></a>进程回收 - wait</h4><p>进程回收必须由父进程主动调用！！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_d wait( int * status);</span><br></pre></td></tr></table></figure>

<ol>
<li>回收成功返回子进程的进程号，失败返回EOR</li>
<li>若当前子进程未结束，父进程一直处于阻塞状态</li>
<li>存在多个子进程，哪个先结束就先回收哪一个</li>
<li>status 指定保存子进程返回值和结束方式的地址(定义整形变量，将该变量的地址作为参数传入)</li>
<li>status为NULL表示不接收PCB信息，直接释放<br>实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> int status;//保存子进程的返回值和结束方式</span><br><span class="line"> pid_ t pid;  //保存新建的进程号</span><br><span class="line"> if((pid = fork())&lt;0)</span><br><span class="line"> &#123;</span><br><span class="line">	 preeor(&quot;fork&quot;);  //创建子进程</span><br><span class="line">	 exit(-1);      //结束进程</span><br><span class="line"> &#125;</span><br><span class="line"> else if(pid == 0) //子进程创建成功返回0</span><br><span class="line"> &#123;</span><br><span class="line"> 	 sleep(1);//休眠一秒</span><br><span class="line"> 	 exit(2);  //结束的进程号是自定义的</span><br><span class="line"> &#125;</span><br><span class="line"> else &#123;</span><br><span class="line">	 wait(&amp;status);</span><br><span class="line">	 printf(&quot;%x\n&quot;,status); //1个字节 8位</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="进程回收-waitpid-指定进程回收"><a href="#进程回收-waitpid-指定进程回收" class="headerlink" title="进程回收 - waitpid (指定进程回收)"></a>进程回收 - waitpid (指定进程回收)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_d waitpid(pid_t pid, int * status,int option);</span><br></pre></td></tr></table></figure>

<ol>
<li>成功时返回回收的子进程的PID 或者 0， 失败时返回EOR（0是表示子进程未结束，此时option参数为WNOHANG）</li>
<li>第一个参数指定某子进程的进程号（指定为-1 表示为 回收任意一个子进程）</li>
<li>status 指定保存子进程返回值和结束方式的地址(定义整形变量，将该变量的地址作为参数传入)</li>
<li>option 是指定回收方式 （0或者WNOHANG ）   （0是阻塞，WNOHANG是非阻塞）<br>（阻塞：若子进程未结束，父进程一直在等待。未阻塞：子进程未结束，父进程不等待直接返回0）</li>
</ol>
<hr>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><h4 id="守护进程的创建"><a href="#守护进程的创建" class="headerlink" title="守护进程的创建"></a>守护进程的创建</h4><ol>
<li><p>创建子进程，父进程退出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(fork()&gt;0)  // 因为子进程返回值是0，只有父进程返回值是非0</span><br><span class="line">&#123;</span><br><span class="line">      exit(0);  //结束父进程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>子进程变为孤儿进程，被init收养</li>
<li>子进程自动变为后台运行（但依旧依赖于当前终端，若终端关闭，进程将被关闭）</li>
</ol>
</li>
<li><p>子进程中创建一个新会话（最重要的一步）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(setsid()&lt;0)</span><br><span class="line"> &#123;</span><br><span class="line">      exit(-1);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>子进程成为新的会话组长</li>
<li>子进程脱离终端</li>
</ol>
</li>
<li><p>修改进程的当前工作目录<br><code>chdir(&quot;/&quot;);或者chidir(&quot;/tmp&quot;);</code></p>
<ol>
<li>守护进程一直在后台运行，其工作目录不能被卸载</li>
<li>重新设定工作目录</li>
</ol>
</li>
<li><p>修改文件权限掩码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(umask(0)  &lt;  0) //设置掩码为0,取反后为1，不会影响任何新建的文件权限</span><br><span class="line">&#123;</span><br><span class="line">    exit(-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>设置的文件掩码只会影响当前的进程</li>
</ol>
</li>
<li><p>关闭从父进程继承的一些文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">for(i = 0; i &lt; getdtablesize();i++) // getdtablesize()是进程能打开的最大文件个数</span><br><span class="line">&#123;</span><br><span class="line"> close (i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>实例：创建守护进程，每隔1S将系统时间写入到文件time.txt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;time.h&gt; //time(),ctime()</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	 pid_d pid;</span><br><span class="line">	 int  i;</span><br><span class="line">	 FILE *fp;</span><br><span class="line">	 time_t t;</span><br><span class="line">	</span><br><span class="line">	//①创建子进程，父进程退出</span><br><span class="line">	  if(pid = fork()&lt;0)</span><br><span class="line">	 &#123;</span><br><span class="line">		 perror(&quot;fork&quot;);</span><br><span class="line">		 exit(-1);  //程序因为创建子进程失败而退出</span><br><span class="line">	 &#125;</span><br><span class="line">	  else if(pid&gt;0)</span><br><span class="line">	&#123;</span><br><span class="line">	          exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	//②创建新的会话</span><br><span class="line">	 setsid();</span><br><span class="line">	//③修改文件掩码</span><br><span class="line">	 umask(0);</span><br><span class="line">	//④修改当前工作目录</span><br><span class="line">	 chdir(&quot;/tmp&quot;);//在用户权限下</span><br><span class="line">	//⑤关闭从父进程继承的文件</span><br><span class="line">	for(i = 0; i &lt; getdtablesize();i++) // getdtablesize()是进程能打开的最大文件个数</span><br><span class="line">	       &#123;</span><br><span class="line">	 	 close (i);</span><br><span class="line">	        &#125;</span><br><span class="line">	//⑥打开文件写入</span><br><span class="line">	 if((fp = fopen(&quot;text.log&quot;,&quot;a+&quot;))==NULL)</span><br><span class="line">	&#123;</span><br><span class="line">	         perror(&quot;fopen&quot;);</span><br><span class="line">	         exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		 time(&amp;t);</span><br><span class="line">		 fprintf(fp,&quot;%s&quot;,ctime(&amp;t));</span><br><span class="line">		 fflush(fp);</span><br><span class="line">		 sleep(1);//一秒的时间间隔</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>IPC：进程间通信，通过内核的缓冲区进行数据交换的机制</p>
<h4 id="ipc通信的方式"><a href="#ipc通信的方式" class="headerlink" title="ipc通信的方式"></a>ipc通信的方式</h4><pre><code>1. Pipe（管道，无名管道，仅支持存在血缘关系通信）
2. fifo（有名管道）
3. Mmap （文件映射共享---速度最快）
4. socket（本地，不是网络socket-----最稳定的形式）
5. 信号signal （携带信息最小的）
6. 共享内存
7. 消息队列</code></pre><h5 id="无名管道（半双工通信）"><a href="#无名管道（半双工通信）" class="headerlink" title="无名管道（半双工通信）"></a>无名管道（半双工通信）</h5><p>不同的进程之间又独自的资源，不可共享，但是父子进程之间可以共享资源。<br>这也就是为什么要先创建管道再创建子进程的原因。（两者可以互相发数据）</p>
<p>父进程使用w端时，子进程使用r端，同理相反。<br> pipfd[0]代表读端，pipefd[1]代表写端<br>（一定要断绝一个进程连接在管道的两端。每个进程间都应该保持唯一和管道的联系close（fd[0]））<br>管道在读取设备时，默认read是阻塞状态，read一直等待，并且直到write写入数据。</p>
<p>读管道：<br>    ○ 写端全部关闭—–read读到0，相当于读取到文件末尾<br>    ○ 写端没有关闭<br>        ○ 有数据—read正常读取数据<br>        ○ 没有数据—read阻塞 ，fcntl函数可以更改阻塞状态</p>
<p>写管道<br>    ○ 读端全部关闭—-产生一个信号，管道崩溃，程序异常终止<br>    ○ 读端未全部关闭<br>        ○ 管道已满（管道的本质就是一个缓冲区）—-写阻塞<br>        ○ 管道未满—-写端正常<br><img src="/2019/06/04/进程/pipe.jpg" alt="图片"><br>计算管道的大小size  ？kb*8<br><code>long fpathconf(int fd,int name)</code><br><code>ulimit -a</code></p>
<p>管道的优劣<br>只有一个函数（pipe）所以简单<br>但是只能用于有血缘关系的进程进行通信，父子进程之间相互通信时，需要创建两个管道（保证安全性所以管道都是单方向通信）。</p>
<hr>
<h5 id="FIFO–有名管道"><a href="#FIFO–有名管道" class="headerlink" title="FIFO–有名管道"></a>FIFO–有名管道</h5><p>实现无血缘关系进行通信。<br>    • 本质是实现了一个管道的伪文件<br>    • Mkfifo name 创建伪文件命令</p>
<p>创建FIFO的函数<br><code>int mkfifo(const char *pathname, mode_t mode);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">	• 文件路径，权限位（0666）</span><br><span class="line">//利用有名管道实现一个进程写入文件，另一个进程读取文件的操作</span><br><span class="line"> #include &lt;unistd.h&gt;</span><br><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line"> #include &lt;sys/types.h&gt;</span><br><span class="line"> #include&lt;sys/stat.h&gt;</span><br><span class="line"> #inlcude &lt;string.h&gt;</span><br><span class="line">//写入端</span><br><span class="line">//前提是已经存在文件 ，不存在的话需要在mode中加入O_CREATE</span><br><span class="line"> int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	 if(argc != 2)//运行时没有指定文件</span><br><span class="line">	&#123; </span><br><span class="line">		printf(&quot;error\n&quot;);</span><br><span class="line">		 return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 int fd = open(argv[1],O_WDONLY);</span><br><span class="line">	 char buf[1024];</span><br><span class="line">	</span><br><span class="line">	 int num = 0;</span><br><span class="line">	 while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		 memset(buf,0,sizeof(buf));//设置默认数据，清空</span><br><span class="line">		 sprintf(buf,&quot;test  %03d&quot;,num++);//将测试数据写入缓冲区</span><br><span class="line">		 write(fd,buf,strlen(buf));//缓冲区数据写入文件中</span><br><span class="line">		</span><br><span class="line">		 sleep(2);//休眠2S执行一次</span><br><span class="line">	&#125;</span><br><span class="line">	 close(fd);</span><br><span class="line">	 return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//读取端，头文件同上，省略</span><br><span class="line">//写入端</span><br><span class="line">//前提是已经存在文件 ，不存在的话需要在mode中加入O_CREATE</span><br><span class="line"> int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	 if(argc != 2)//运行时没有指定读取文件</span><br><span class="line">	&#123; </span><br><span class="line">		printf(&quot;error\n&quot;);</span><br><span class="line">		 return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 int fd = open(argv[1],O_RDONLY);</span><br><span class="line">	 char buf[1024];</span><br><span class="line">	</span><br><span class="line">	 int temp;</span><br><span class="line">	 while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		 temp = read(fd,buf,sizeof(buf));</span><br><span class="line">		 if(temp &gt;0)//文件中存在数据</span><br><span class="line">		&#123;</span><br><span class="line">			 printf(&quot;read data:%s\n&quot;,buf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 close(fd);</span><br><span class="line">	 return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">##### mmap函数映射</span><br><span class="line">通过映射的形式将文件映射到内存中，便于多个进程之间互相来通信（取决于flags的状态）。</span><br><span class="line">函数原型</span><br></pre></td></tr></table></figure>

<p>void *mmap(void * addr,size_t length,int prot,int flags,int fd, off_t offset)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">	1. addr参数传入NULL,</span><br><span class="line">	2. flags参数存在两种类型，其一是MMAP_SHARE(更改内存可以影响到源文件)，第二就是MMAP_PRIVATE(私有化，不影响源文件)，</span><br><span class="line">	3. prot参数一般使用MMAP_READ,MMAP_WRITE两种，</span><br><span class="line">	4. fd是文件描述符，</span><br><span class="line">	5. offset是地址偏移量(也就是需要映射的文件的起始地址),length是需要映射的内容的长度</span><br><span class="line">	6. 返回值，成功映射返回映射区域的首地址，失败返回一个宏(MMAP_FAILED)</span><br><span class="line">	</span><br><span class="line">一般的映射步骤：</span><br><span class="line">open打开文件，返回一个fd，在mmap中传入fd，判断mmap的返回值，在使用munmap关闭映射。</span><br><span class="line"></span><br><span class="line">同样munmap函数是释放映射内存的函数</span><br><span class="line">`int munmap(int fd, int length)`</span><br><span class="line">参数fd就是映射成功返回的首地址，length是用映射文件的长度</span><br><span class="line"></span><br><span class="line">注意事项</span><br><span class="line">①如果mmap函数成功返回的地址，一定不能更改，否则munmap不能释放。</span><br><span class="line">②mmap越界操作(写入超过length)时是否能写入取决于文件内容的长度。</span><br><span class="line">③offset必须是4k的整数倍，不能随便填</span><br><span class="line">④文件描述符先关闭不影响mmap函数的映射</span><br><span class="line">⑤open创建新文件时文件大小若为0则不可作为mmap函数的映射文件，必须是大小不为0的文件</span><br><span class="line">⑥open的权限应该＞=prot的权限</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">匿名映射，不需要open文件，prot参数加上MAP_ANON，并且fd传入-1</span><br><span class="line">``` </span><br><span class="line">eg:将一个文件映射，权限为可读可写`</span><br><span class="line">char *mmap(NULL,sizeof(length),MAP_ANON|PROT_READ|</span><br><span class="line">PROT_WRITE,MAP_SHARED,-1,0)</span><br><span class="line"></span><br><span class="line">在unix中没有MAP_ANON和MAP_ANONYMOUS这两个宏，一般都用以下两个文件代替</span><br></pre></td></tr></table></figure>

<p>dev/zero  聚宝盆，可以随意映射<br>dev/null   无底洞，不占用磁盘空间</p>
<hr>
<h5 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h5><p>四要素：<br>• 编号<br>• 名称<br>• 事件<br>• 默认动作：<br>   Term：终止进程<br>   Ign： 忽略信号 (默认即时对该种信号忽略操作)<br>   Core：终止进程，生成Core文件。<br>   Stop：停止（暂停）进程<br>   Cont：继续运行进程<br>特点：<br>• 简单，不能携带大量信息<br>• 特定条件下产生<br>• 也称作软中断，有可能会有延迟<br>处理方式<br>• 执行默认动作<br>• 忽略<br>• 捕捉<br>9(SIGKILL)，19号(SIGSTOP)信号不能捕捉，忽略，并且不能阻塞。</p>
<h6 id="未决信号集和阻塞信号集"><a href="#未决信号集和阻塞信号集" class="headerlink" title="未决信号集和阻塞信号集"></a>未决信号集和阻塞信号集</h6><p>（0为已经处理，1为未处理）<br>阻塞信号集可以人为的设置信号的状态（以2号信号为例）<br>阻塞信号使2号位变为1，未决信号集也变为了1，此时产生了一个2号信号传递过来，因为在阻塞状态，所以未决信号集不处理，只能等阻塞信号集的该位变为0，未决信号集才会去处理。<br><img src="/2019/06/04/进程/%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86.png" alt="图片"></p>
<h6 id="所有信号"><a href="#所有信号" class="headerlink" title="所有信号"></a>所有信号</h6><p>通过<code>kill -l</code>或者<code>man 7 signal</code>查看所有信号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1	64) SIGRTMAX</span><br><span class="line">不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同</span><br></pre></td></tr></table></figure>

<p>####### 信号的默认处理事件<br>Signal         Value     Action   Comment<br>─────────────────────────────────────<br>SIGHUP          1       Term    终端线路被挂断<br>SIGINT           2       Term    中断进程<br>SIGQUIT          3       Core    终止进程<br>SIGILL            4       Core    非法指令<br>SIGFPE           8       Core    浮点异常<br>SIGKILL           9       Term    杀死进程（不可捕捉，忽略，只能执行默认动作）<br>SIGSEGV         11      Core    段错误<br>SIGPIPE       13      Term    向一个没有读进程的管道写数据<br>SIGALRM        14      Term    计数器时间到<br>SIGTERM         15      Term    软件终止信号<br>SIGUSR1   30,10,16    Term    用户自定义信号1<br>SIGUSR2   31,12,17    Term    用户自定义信号2<br>SIGCHLD   20,17,18    Ign     子进程停止或者退出时通知父进程<br>SIGCONT   19,18,25    Cont    继续执行一个停止的进程<br>SIGSTOP   17,19,23    Stop    非终端的停止信号<br>SIGTSTP   18,20,24    Stop    终端发来的通知信号<br>SIGTTIN   21,21,26    Stop   后台进程读终端<br>SIGTTOU   22,22,27   Stop   后台进程写终端</p>
<h6 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h6><p>①按键产生的信号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + c  → 2) SIGINT（终止/中断）	</span><br><span class="line">Ctrl + z  → 20) SIGTSTP（暂停/停止） </span><br><span class="line">Ctrl + \  → 3) SIGQUIT（退出）</span><br></pre></td></tr></table></figure>

<p>②异常产生信号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">除0操作   → 8) SIGFPE (浮点数例外)	</span><br><span class="line">非法访问内存  → 11) SIGSEGV (段错误)</span><br><span class="line">总线错误  → 7) SIGBUS</span><br></pre></td></tr></table></figure>

<p>③时钟产生信号<br>alarm函数—定义多久时间后发送一个信号<br><code>unsigned int alarm(unsigned int seconds)</code><br>定时给自己发送SIGALRM信号（经过*s自动终止进程）<br>返回值是上一次闹钟被触发剩余的秒数，若闹钟已经被触发或者只有一个闹钟则返回0<br>（先设置alarm(5),经过两秒又设置一个alarm(3)，则函数的返回值就是距离第一个闹钟被触发的秒数，3秒）<br>参数传入0就是取消闹钟</p>
<p>setitimer函数—可以周期性的发送信号（每隔多长时间发送信号）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int setitimer(int which,const struct itimerval *new_value,struct itimerval *old_value);</span><br><span class="line"></span><br><span class="line">struct itimerval &#123;</span><br><span class="line">    struct timeval it_interval; /* 周期性 */</span><br><span class="line">    struct timeval it_value;    /* 下一次定时时间 */</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">    struct timeval &#123;</span><br><span class="line">         time_t      tv_sec;         /* 秒 */</span><br><span class="line">         suseconds_t tv_usec;        /* 微秒 */</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>参数部分：</p>
<ol>
<li>which存在三个宏（ITIMER_REAL（SIGALRM）,ITIMER_VIRTUAL（SIGVTALRM）,ITIMER_PROF（SIGPROF））三种时间计算方式</li>
<li>new_value 要设置的闹钟时间</li>
<li>old_value 原来闹钟的时间</li>
<li>④系统api产生信号<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">int kill(pid_t pid,int sig)</span><br><span class="line"></span><br><span class="line">eg:创建3个进程，1号进程在3s后杀死父进程</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> int main()</span><br><span class="line">&#123;</span><br><span class="line">	 int i=0;</span><br><span class="line">	 for(;i&lt;3;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		 pid_t pid= fork();//创建三个进程，0，1，2</span><br><span class="line">	&#125;</span><br><span class="line">	 if(pid == 1)</span><br><span class="line">	&#123;//1号子进程</span><br><span class="line">		 printf(&quot;son ,but kill father after 3s&quot;);</span><br><span class="line">		 sleep(3);</span><br><span class="line">		 kill(getppid(),SIGKILL);</span><br><span class="line">		while(1)</span><br><span class="line">		&#123;</span><br><span class="line">			 sleep(1);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	 else if(pid == 3)</span><br><span class="line">	&#123;//父进程</span><br><span class="line">		 while(1)</span><br><span class="line">		&#123;</span><br><span class="line">			 printf(&quot;father&quot;);</span><br><span class="line">			 sleep(1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="raise和abort"><a href="#raise和abort" class="headerlink" title="raise和abort"></a>raise和abort</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int raise(int sig)---自己给自己发信号（可以自己杀死自己）</span><br><span class="line">void abort(void)---直接给自己发一个异常信号SIGABRT</span><br></pre></td></tr></table></figure>

<h6 id="信号注册函数"><a href="#信号注册函数" class="headerlink" title="信号注册函数"></a>信号注册函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*sighandler_t)(int);//函数指针，参数为int型，处理捕捉到的信号</span><br><span class="line"> sighandler_t signal(int signum, sighandler_t handler);//信号，处理函数</span><br></pre></td></tr></table></figure>

<ol>
<li>signum 要捕捉的信号</li>
<li>sighandler_t 要执行的捕捉函数指针（函数声明为 <code>void func(int )</code>）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">eg:捕捉SIGALRM信号</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line">void catch_sig(int num)//处理捕捉到的信号</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;catch %d signal\n&quot;,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	signal(SIGALRM,catch_sig); //获取信号，并且处理</span><br><span class="line">	struct itimerval myit = &#123;&#123;2,0&#125;,&#123;6,0&#125;&#125;;//第一次定时6s，以后的时间周期是2s</span><br><span class="line">	setitimer(ITIMER_REAL,&amp;myit,NULL);</span><br><span class="line"></span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;i will die\n&quot;);</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eg:利用setitimer实现alarm功能</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//unsigned int alarm(unsigned int seconds)</span><br><span class="line"></span><br><span class="line">unsigned int myalarm(unsigned int seconds)</span><br><span class="line">&#123;</span><br><span class="line">	struct itimerval myit = &#123;&#123;0,0&#125;,&#123;0,0&#125;&#125;;</span><br><span class="line">	struct itimerval oldit;</span><br><span class="line">	myit.it_value.tv_sec = seconds;</span><br><span class="line">	setitimer(ITIMER_REAL,&amp;myit,&amp;oldit);</span><br><span class="line">	return oldit.it_value.tv_sec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int rec = 0;</span><br><span class="line"></span><br><span class="line">	rec = myalarm(5);</span><br><span class="line">	printf(&quot;rec = %d\n&quot;,rec);//rec保存上一次定时的时间，因为是第一次定时，所以会输出0</span><br><span class="line">	sleep(2);</span><br><span class="line">	rec = myalarm(2);</span><br><span class="line">	printf(&quot;rec = %d\n&quot;,rec);//rec保存距离当前定时的时间</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;i will die\n&quot;);</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="信号集处理函数"><a href="#信号集处理函数" class="headerlink" title="信号集处理函数"></a>信号集处理函数</h6><p>使用<code>man sigemptyset</code>可以查看信号集函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int sigemptyset(sigset_t *set);--清空信号集，全部变为0</span><br><span class="line">int sigfillset(sigset_t *set);---填充信号集，全部变为1</span><br><span class="line">int sigaddset(sigset_t *set, int signum);--添加某个信号到信号集</span><br><span class="line">int sigdelset(sigset_t *set, int signum);--从信号集中删除某个信号</span><br><span class="line">int sigismember(const sigset_t *set, int signum);--某个信号是否存在在信号集中</span><br></pre></td></tr></table></figure>

<p>返回值中只有sigismenmber函数返回1代表signum在set信号集中，返回0代表不再信号集中。其余函数均返回0代表成功，返回-1代表失败。</p>
<ol>
<li>设置阻塞或者解除信号集阻塞状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>参数：<br>①how存在三种SIG_BLOCK、SIG_SETMASK（直接设置set阻塞信号集）、SIG_UNBLOCK（解除阻塞）<br>②oldset是便于恢复现场,不需要时传入NULL</p>
<ol start="2">
<li>获取未决信号集的状态<br><code>int sigpending(sigset_t *set);</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">eg:通过设置阻塞信号集，来打印出当前进程的所有信号状态</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//设置阻塞信号</span><br><span class="line">	sigset_t sigproc;</span><br><span class="line">	//清空信号集</span><br><span class="line">	sigemptyset(&amp;sigproc);</span><br><span class="line"></span><br><span class="line">	//添加一个信号到阻塞信号集中</span><br><span class="line">	sigaddset(&amp;sigproc,SIGINT);</span><br><span class="line">	sigaddset(&amp;sigproc,SIGQUIT);</span><br><span class="line">	</span><br><span class="line">	//设置阻塞信号集</span><br><span class="line">	sigprocmask(SIG_BLOCK,&amp;sigproc,NULL); //不保留原状态</span><br><span class="line"></span><br><span class="line">	//获取未决信号集的状态</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		sigset_t pend;</span><br><span class="line">		sigpending(&amp;pend);</span><br><span class="line">		int i = 1; //1-31号信号</span><br><span class="line">		for(;i&lt;32;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(sigismember(&amp;pend,i)==1) //如果信号在信号集中</span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;1&quot;);</span><br><span class="line">			&#125;else</span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;0&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h6><p>其中一个功能是为了防止需要的信号被内核自动处理，从而达不到我们所要求的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int sigaction(int signum, const struct sigaction *act,</span><br><span class="line">                     struct sigaction *oldact);</span><br><span class="line">结构体：</span><br><span class="line">struct sigaction &#123;</span><br><span class="line">               void     (*sa_handler)(int);//函数指针，捕捉函数需要执行的函数</span><br><span class="line">               void     (*sa_sigaction)(int, siginfo_t *, void *);//sa_flags != 0时执行这个捕捉函数，一般不使用</span><br><span class="line">               sigset_t   sa_mask;//捕捉函数期间，临时屏蔽的信号集</span><br><span class="line">               int        sa_flags; //一般写0</span><br><span class="line">               void     (*sa_restorer)(void);</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">①signum捕捉的信号，act传入的动作，oldact原动作</span><br><span class="line">还有一个就是上面的信号注册捕捉</span><br></pre></td></tr></table></figure>

<h6 id="信号的捕捉特性"><a href="#信号的捕捉特性" class="headerlink" title="信号的捕捉特性"></a>信号的捕捉特性</h6><ol>
<li>进程正常运行时，默认PCB中有一个信号屏蔽字，假定为☆，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号以后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号不由☆来指定。而是用sa_mask来指定。调用完信号处理函数，再恢复为☆。</li>
<li>XXX信号捕捉函数执行期间，XXX信号自动被屏蔽。</li>
<li>阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">eg:使用sigaction进行捕捉信号</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line">void catch_sig(int num) //捕捉到信号之后的处理函数</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;catch %d signal\n&quot;,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	struct sigaction act;</span><br><span class="line">	act.sa_flags = 0;</span><br><span class="line">	//flags为0 的时候默认执行第一个捕捉函数</span><br><span class="line">	act.sa_handler = catch_sig;</span><br><span class="line">	//清空临时的屏蔽信号集</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	</span><br><span class="line">	//添加一个临时捕捉信号sa_mask</span><br><span class="line">	 sigaddset(&amp;act.sa_mask,SIGTSTP);//crtl+z按键产生的信号</span><br><span class="line">	//注册捕捉函数</span><br><span class="line">	sigaction(SIGALRM,&amp;act,NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//signal(SIGALRM,catch_sig);</span><br><span class="line">	struct itimerval myit = &#123;&#123;3,0&#125;,&#123;5,0&#125;&#125;;</span><br><span class="line">	//定时时钟函数</span><br><span class="line">	setitimer(ITIMER_REAL,&amp;myit,NULL);</span><br><span class="line"></span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;i will die\n &quot;);</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="内核对信号的处理过程"><a href="#内核对信号的处理过程" class="headerlink" title="内核对信号的处理过程"></a>内核对信号的处理过程</h6><p>在用户模式下，产生的信号或者信号到达，系统内核会自动接管程序，如果此时存在该信号的捕捉函数，就会交由捕捉函数的处理函数进行执行，待其执行完成后再返回给内核，如果此信号没有捕捉函数则由内核的信号默认处理动作执行，最后内核将处理结果再交由产生信号的下一句程序来执行。</p>
<hr>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/02/库/" rel="next" title="库">
                <i class="fa fa-chevron-left"></i> 库
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/19/线程/" rel="prev" title="线程">
                线程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Zurdo">
          <p class="site-author-name" itemprop="name">Zurdo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程"><span class="nav-number">1.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#程序"><span class="nav-number">1.1.</span> <span class="nav-text">程序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#定义"><span class="nav-number">1.1.1.</span> <span class="nav-text">定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的类型"><span class="nav-number">1.2.</span> <span class="nav-text">进程的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的状态"><span class="nav-number">1.3.</span> <span class="nav-text">进程的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux中查看进程信息"><span class="nav-number">1.4.</span> <span class="nav-text">Linux中查看进程信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的相关命令"><span class="nav-number">1.5.</span> <span class="nav-text">进程的相关命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的相关函数"><span class="nav-number">2.</span> <span class="nav-text">进程的相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#父子进程"><span class="nav-number">2.1.</span> <span class="nav-text">父子进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的返回值和结束方式"><span class="nav-number">2.2.</span> <span class="nav-text">进程的返回值和结束方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程创建-fork"><span class="nav-number">2.3.</span> <span class="nav-text">进程创建 - fork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程结束-exit-exit"><span class="nav-number">2.4.</span> <span class="nav-text">进程结束 - exit/_exit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程-exec函数族"><span class="nav-number">2.5.</span> <span class="nav-text">进程 - exec函数族</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程回收-wait"><span class="nav-number">2.6.</span> <span class="nav-text">进程回收 - wait</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程回收-waitpid-指定进程回收"><span class="nav-number">2.7.</span> <span class="nav-text">进程回收 - waitpid (指定进程回收)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#守护进程"><span class="nav-number">3.</span> <span class="nav-text">守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#守护进程的创建"><span class="nav-number">3.1.</span> <span class="nav-text">守护进程的创建</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程间通信"><span class="nav-number">4.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ipc通信的方式"><span class="nav-number">4.1.</span> <span class="nav-text">ipc通信的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#无名管道（半双工通信）"><span class="nav-number">4.1.1.</span> <span class="nav-text">无名管道（半双工通信）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FIFO–有名管道"><span class="nav-number">4.1.2.</span> <span class="nav-text">FIFO–有名管道</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#信号"><span class="nav-number">4.1.3.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#未决信号集和阻塞信号集"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">未决信号集和阻塞信号集</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#所有信号"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">所有信号</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#信号的产生"><span class="nav-number">4.1.3.3.</span> <span class="nav-text">信号的产生</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#raise和abort"><span class="nav-number">4.1.3.4.</span> <span class="nav-text">raise和abort</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#信号注册函数"><span class="nav-number">4.1.3.5.</span> <span class="nav-text">信号注册函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#信号集处理函数"><span class="nav-number">4.1.3.6.</span> <span class="nav-text">信号集处理函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#信号捕捉"><span class="nav-number">4.1.3.7.</span> <span class="nav-text">信号捕捉</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#信号的捕捉特性"><span class="nav-number">4.1.3.8.</span> <span class="nav-text">信号的捕捉特性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#内核对信号的处理过程"><span class="nav-number">4.1.3.9.</span> <span class="nav-text">内核对信号的处理过程</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zurdo</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  

  


</body>
</html>
<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>