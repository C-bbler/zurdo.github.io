<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh_CH">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Linux,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="进程程序 存放在磁盘中的指令和数据的有序集合。 是静态的。">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="进程">
<meta property="og:url" content="http://yoursite.com/2019/06/04/进程/index.html">
<meta property="og:site_name" content="Zurdo">
<meta property="og:description" content="进程程序 存放在磁盘中的指令和数据的有序集合。 是静态的。">
<meta property="og:locale" content="zh_CH">
<meta property="og:image" content="http://yoursite.com/2019/06/04/进程/%E8%BF%9B%E7%A8%8B.png">
<meta property="og:image" content="http://yoursite.com/2019/06/04/进程/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png">
<meta property="og:image" content="http://yoursite.com/2019/06/04/进程/%E4%BD%9C%E4%B8%9A%E5%8F%B7.png">
<meta property="og:image" content="http://yoursite.com/2019/06/04/进程/pipe.png">
<meta property="og:updated_time" content="2019-10-07T12:06:47.920Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="进程">
<meta name="twitter:description" content="进程程序 存放在磁盘中的指令和数据的有序集合。 是静态的。">
<meta name="twitter:image" content="http://yoursite.com/2019/06/04/进程/%E8%BF%9B%E7%A8%8B.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/06/04/进程/">





  <title> 进程 | Zurdo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh_CH">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zurdo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/04/进程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zurdo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zurdo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                进程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-04T19:23:01+08:00">
                2019-06-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><ol>
<li>存放在磁盘中的指令和数据的有序集合。</li>
<li>是静态的。</li>
</ol>
<a id="more"></a>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ol>
<li>执行程序时系统分配的所有资源的总称。</li>
<li>进程是程序的一次执行过程。</li>
<li>进程是动态的，包括创建、调度、执行、消亡。</li>
</ol>
<p><img src="/2019/06/04/进程/%E8%BF%9B%E7%A8%8B.png" alt="图片"></p>
<p>进程控制块（PCb）包括以下几个部分：</p>
<ol>
<li>进程标识（PID）</li>
<li>进程用户（由哪个用户创建）</li>
<li>进程的状态、优先级</li>
<li>文件描述符（记录当前进程打开了哪些文件）</li>
</ol>
<h4 id="进程的类型"><a href="#进程的类型" class="headerlink" title="进程的类型"></a>进程的类型</h4><ol>
<li>交互类型</li>
<li>批处理进程</li>
<li>守护进程</li>
</ol>
<p>①交互类型（前台进程：可以在终端输入/输出，后台进程：可以在终端输入，可以输出）在shell下启动，可以在前台运行，也可以在后台运行<br>②批处理进程   ： 和在终端无关，被提交到一个作业队列中以便顺序执行<br>③守护进程  ： 和终端无关，一直在后台运行</p>
<h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><ol>
<li>运行态：正在运行或者就绪态</li>
<li>等待态（阻塞态/睡眠态）：进程在等待一个实际按的发生或某种系统的释放<ol>
<li>可中断</li>
<li>不可中断</li>
</ol>
</li>
<li>停止态：进程被终止，收到信号后可以恢复运行</li>
<li>死亡态（僵尸态）：已中止的进程，但是pcb没有释放，其他资源都被释放（pcb存放的是进程的返回值和结束方式，这些信息必须由父进程回收处理）<br><img src="/2019/06/04/进程/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="图片"></li>
</ol>
<h4 id="Linux中查看进程信息"><a href="#Linux中查看进程信息" class="headerlink" title="Linux中查看进程信息"></a>Linux中查看进程信息</h4><ol>
<li>ps   查看系统进程快照<br>常用格式： <code>ps -ef|more</code>查看所有进程分页显示   <code>ps-ef|grep</code> 查找指定进程</li>
<li>top  查看进程的动态信息</li>
<li>/proc  查看进程的详细信息<br>使用格式：<code>cd /proc  进程号</code></li>
</ol>
<h4 id="进程的相关命令"><a href="#进程的相关命令" class="headerlink" title="进程的相关命令"></a>进程的相关命令</h4><ol>
<li>nice 指定数字（[-20,19]数字越小优先级越高，默认为0），来修改进程的优先级（普通用户指定的数字最小是0）<br> 命令格式：<code>nice -n 2 ./test</code></li>
<li>renice 改变一个已经在执行的进程优先级<br> 命令格式：<code>renice -n 2  进程号</code></li>
<li>jobs   查看终端上的后台进程</li>
<li>bg   让一个后台作业在后台运行（由停止态变为运行态）</li>
<li>fg  将后台运行的进程变为前台进程运行<br> 命令格式：<code>fg  作业号</code><br><img src="/2019/06/04/进程/%E4%BD%9C%E4%B8%9A%E5%8F%B7.png" alt="图片"></li>
<li>将正在运行的前台进程变为后台挂起<br>快捷键   ctrl + z</li>
</ol>
<hr>
<h3 id="进程的相关函数"><a href="#进程的相关函数" class="headerlink" title="进程的相关函数"></a>进程的相关函数</h3><h4 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h4><ol>
<li>子进程继承父进程的内容（代码，指令，数据….）</li>
<li>父子进程有独立的空间地址，互不影响</li>
<li>若父进程先结束<ol>
<li>子进程称为孤儿进程，被  init 进程 （内核启动后创建的第一个用户进程，进程号为1） 收养</li>
<li>子进程若在前台运行，自动变为后台进程</li>
</ol>
</li>
<li>若子进程先结束<ol>
<li>父进程没有及时回收，子进程变为僵尸进程</li>
</ol>
</li>
<li>子进程从fork函数后的第一条语句开始执行</li>
</ol>
<h4 id="进程的返回值和结束方式"><a href="#进程的返回值和结束方式" class="headerlink" title="进程的返回值和结束方式"></a>进程的返回值和结束方式</h4><ol>
<li>子进程通过_exit/exit/return 返回某个值（0~255）（正常结束）</li>
<li>父进程调用wait(&amp;status)回收 （非正常结束）<ol>
<li>WIFEXITED(status)         系统宏 ，判断子进程是否正常结束</li>
<li>WEXITSTATUS(status)    获取子进程的返回值</li>
<li>WIFSIGNLED(status)    判断子进程是否被信号结束</li>
<li>WTERMSIG (status)      获取子进程的信号类型<br>（status的低七位是0，表示正常结束；低七位是非0，表示是被信号结束的，并且低七位表示的是信号的类型）</li>
</ol>
</li>
</ol>
<h4 id="进程创建-fork"><a href="#进程创建-fork" class="headerlink" title="进程创建 - fork"></a>进程创建 - fork</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_d  fork(void);</span><br></pre></td></tr></table></figure>

<ol>
<li>创建新的进程，失败返回EOR</li>
<li>创建成功父进程返回子进程的进程号，子进程返回0</li>
<li>通过fork的返回值区分父子进程</li>
</ol>
<p>实例：创建一个子进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">	 pid_t pid;//函数的返回值类型</span><br><span class="line">	</span><br><span class="line">	 if((pid = fork())&lt;0)//创建失败</span><br><span class="line">	&#123;</span><br><span class="line">		 perror(&quot;fork&quot;);</span><br><span class="line">		 return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	//getpid();   获取进程号</span><br><span class="line">	 else if(pid == 0)//子进程</span><br><span class="line">	 &#123;</span><br><span class="line">	 	 printf(&quot;this child process\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	 else</span><br><span class="line">	 &#123;</span><br><span class="line">		  printf(&quot;this parent process\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	 return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="进程结束-exit-exit"><a href="#进程结束-exit-exit" class="headerlink" title="进程结束 - exit/_exit"></a>进程结束 - exit/_exit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include  &lt;stdlib.h&gt;</span><br><span class="line">void exit(int status);  //status是需要结束的进程号</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void _exit(int status);</span><br></pre></td></tr></table></figure>

<ol>
<li>exit(-1) 表示因为某些异常而结束进程</li>
<li>exit(0)  表示正常结束</li>
<li>exit()在结束进程的时候会刷新流的缓冲区，_exit()不刷新</li>
</ol>
<h4 id="进程-exec函数族"><a href="#进程-exec函数族" class="headerlink" title="进程 - exec函数族"></a>进程 - exec函数族</h4><p>(函数族的作用：在一个进程中启动一个新的进程)</p>
<ol>
<li><p>进程调用exec函数族执行某个程序</p>
</li>
<li><p>进程当前内容被指定的程序替换</p>
</li>
<li><p>实现让父子进程执行不同的程序</p>
<ol>
<li>父进程创建子进程</li>
<li>子进程调用exec函数族</li>
<li>父进程不受影响</li>
</ol>
</li>
<li><p>进程 - execl/execlp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int execl(const char *path,const char *arg,…..);</span><br><span class="line">int execlp(const char *file,const char *arg,…..);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>①path应该包含完整路径，可以是相对路径，也可以是绝对路径<br>②成功时执行指定的程序，失败返回EOR<br>③arg…  传递给程序的参数列表(类似于main函数传参)，最后一个参数必须为NULL<br>④file 执行的程序名称，在path中查找该程序<br>eg ：执行ls命令，显示etc目录下所有文件的详细信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(excel(&quot;/bin/ls&quot;,&quot;-a&quot;,&quot;-l&quot;,&quot;etc&quot;,NULL)&lt;0)</span><br><span class="line">	 perror(&quot;execl&quot;);</span><br><span class="line">if(excelp(&quot;ls&quot;,&quot;-a&quot;,&quot;-l&quot;,&quot;etc&quot;,NULL)&lt;0)</span><br><span class="line">		 perror(&quot;execlp&quot;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>进程 - execv/execvp<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> int execv(const char *path,const char *arg[]);</span><br><span class="line"> int execvp(const char *file,const char *arg[]);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>①成功执行指定程序，失败返回EOR<br>② arg.. 封装成指针数组的形式</p>
<p>eg ：执行ls命令，显示etc目录下所有文件的详细信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char *arg[] = &#123;&quot;ls&quot;,&quot;-a&quot;,&quot;-l&quot;,&quot;etc&quot;,NULL&#125;</span><br><span class="line">if(excev(&quot;/bin/ls&quot;,arg)&lt;0)</span><br><span class="line">	 perror(&quot;execv&quot;);</span><br><span class="line">if(excevp(&quot;ls&quot;,arg)&lt;0)</span><br><span class="line">	 perror(&quot;execvp&quot;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进程 - system<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int system(const char *command)；</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>①在当前进程中自动创建一个子进程，执行command所包含的程序<br>②父进程一直等待子进程执行完成，才继续向下执行程序(阻塞状态)<br>③成功执行返回command的返回值，失败返回EOR</p>
<h4 id="进程回收-wait"><a href="#进程回收-wait" class="headerlink" title="进程回收 - wait"></a>进程回收 - wait</h4><p>进程回收必须由父进程主动调用！！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_d wait( int * status);</span><br></pre></td></tr></table></figure>

<ol>
<li>回收成功返回子进程的进程号，失败返回EOR</li>
<li>若当前子进程未结束，父进程一直处于阻塞状态</li>
<li>存在多个子进程，哪个先结束就先回收哪一个</li>
<li>status 指定保存子进程返回值和结束方式的地址(定义整形变量，将该变量的地址作为参数传入)</li>
<li>status为NULL表示不接收PCB信息，直接释放<br>实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> int status;//保存子进程的返回值和结束方式</span><br><span class="line"> pid_ t pid;  //保存新建的进程号</span><br><span class="line"> if((pid = fork())&lt;0)</span><br><span class="line"> &#123;</span><br><span class="line">	 preeor(&quot;fork&quot;);  //创建子进程</span><br><span class="line">	 exit(-1);      //结束进程</span><br><span class="line"> &#125;</span><br><span class="line"> else if(pid == 0) //子进程创建成功返回0</span><br><span class="line"> &#123;</span><br><span class="line"> 	 sleep(1);//休眠一秒</span><br><span class="line"> 	 exit(2);  //结束的进程号是自定义的</span><br><span class="line"> &#125;</span><br><span class="line"> else &#123;</span><br><span class="line">	 wait(&amp;status);</span><br><span class="line">	 printf(&quot;%x\n&quot;,status); //1个字节 8位</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="进程回收-waitpid-指定进程回收"><a href="#进程回收-waitpid-指定进程回收" class="headerlink" title="进程回收 - waitpid (指定进程回收)"></a>进程回收 - waitpid (指定进程回收)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_d waitpid(pid_t pid, int * status,int option);</span><br></pre></td></tr></table></figure>

<ol>
<li>成功时返回回收的子进程的PID 或者 0， 失败时返回EOR（0是表示子进程未结束，此时option参数为WNOHANG）</li>
<li>第一个参数指定某子进程的进程号（指定为-1 表示为 回收任意一个子进程）</li>
<li>status 指定保存子进程返回值和结束方式的地址(定义整形变量，将该变量的地址作为参数传入)</li>
<li>option 是指定回收方式 （0或者WNOHANG ）   （0是阻塞，WNOHANG是非阻塞）<br>（阻塞：若子进程未结束，父进程一直在等待。未阻塞：子进程未结束，父进程不等待直接返回0）</li>
</ol>
<hr>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><h4 id="守护进程的创建"><a href="#守护进程的创建" class="headerlink" title="守护进程的创建"></a>守护进程的创建</h4><ol>
<li><p>创建子进程，父进程退出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(fork()&gt;0)  // 因为子进程返回值是0，只有父进程返回值是非0</span><br><span class="line">&#123;</span><br><span class="line">      exit(0);  //结束父进程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>子进程变为孤儿进程，被init收养</li>
<li>子进程自动变为后台运行（但依旧依赖于当前终端，若终端关闭，进程将被关闭）</li>
</ol>
</li>
<li><p>子进程中创建一个新会话（最重要的一步）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(setsid()&lt;0)</span><br><span class="line"> &#123;</span><br><span class="line">      exit(-1);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>子进程成为新的会话组长</li>
<li>子进程脱离终端</li>
</ol>
</li>
<li><p>修改进程的当前工作目录<br><code>chdir(&quot;/&quot;);或者chidir(&quot;/tmp&quot;);</code></p>
<ol>
<li>守护进程一直在后台运行，其工作目录不能被卸载</li>
<li>重新设定工作目录</li>
</ol>
</li>
<li><p>修改文件权限掩码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(umask(0)  &lt;  0) //设置掩码为0,取反后为1，不会影响任何新建的文件权限</span><br><span class="line">&#123;</span><br><span class="line">    exit(-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>设置的文件掩码只会影响当前的进程</li>
</ol>
</li>
<li><p>关闭从父进程继承的一些文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">for(i = 0; i &lt; getdtablesize();i++) // getdtablesize()是进程能打开的最大文件个数</span><br><span class="line">&#123;</span><br><span class="line"> close (i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>实例：创建守护进程，每隔1S将系统时间写入到文件time.txt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;time.h&gt; //time(),ctime()</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	 pid_d pid;</span><br><span class="line">	 int  i;</span><br><span class="line">	 FILE *fp;</span><br><span class="line">	 time_t t;</span><br><span class="line">	</span><br><span class="line">	//①创建子进程，父进程退出</span><br><span class="line">	  if(pid = fork()&lt;0)</span><br><span class="line">	 &#123;</span><br><span class="line">		 perror(&quot;fork&quot;);</span><br><span class="line">		 exit(-1);  //程序因为创建子进程失败而退出</span><br><span class="line">	 &#125;</span><br><span class="line">	  else if(pid&gt;0)</span><br><span class="line">	&#123;</span><br><span class="line">	          exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	//②创建新的会话</span><br><span class="line">	 setsid();</span><br><span class="line">	//③修改文件掩码</span><br><span class="line">	 umask(0);</span><br><span class="line">	//④修改当前工作目录</span><br><span class="line">	 chdir(&quot;/tmp&quot;);//在用户权限下</span><br><span class="line">	//⑤关闭从父进程继承的文件</span><br><span class="line">	for(i = 0; i &lt; getdtablesize();i++) // getdtablesize()是进程能打开的最大文件个数</span><br><span class="line">	       &#123;</span><br><span class="line">	 	 close (i);</span><br><span class="line">	        &#125;</span><br><span class="line">	//⑥打开文件写入</span><br><span class="line">	 if((fp = fopen(&quot;text.log&quot;,&quot;a+&quot;))==NULL)</span><br><span class="line">	&#123;</span><br><span class="line">	         perror(&quot;fopen&quot;);</span><br><span class="line">	         exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		 time(&amp;t);</span><br><span class="line">		 fprintf(fp,&quot;%s&quot;,ctime(&amp;t));</span><br><span class="line">		 fflush(fp);</span><br><span class="line">		 sleep(1);//一秒的时间间隔</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>IPC：进程间通信，通过内核的缓冲区进行数据交换的机制</p>
<h4 id="ipc通信的方式"><a href="#ipc通信的方式" class="headerlink" title="ipc通信的方式"></a>ipc通信的方式</h4><pre><code>1. Pipe（管道，无名管道，仅支持存在血缘关系通信）
2. fifo（有名管道）
3. Mmap （文件映射共享---速度最快）
4. socket（本地，不是网络socket-----最稳定的形式）
5. 信号signal （携带信息最小的）
6. 共享内存
7. 消息队列</code></pre><h5 id="无名管道（半双工通信）"><a href="#无名管道（半双工通信）" class="headerlink" title="无名管道（半双工通信）"></a>无名管道（半双工通信）</h5><p>不同的进程之间又独自的资源，不可共享，但是父子进程之间可以共享资源。<br>这也就是为什么要先创建管道再创建子进程的原因。（两者可以互相发数据）</p>
<p>父进程使用w端时，子进程使用r端，同理相反。<br> pipfd[0]代表读端，pipefd[1]代表写端<br>（一定要断绝一个进程连接在管道的两端。每个进程间都应该保持唯一和管道的联系close（fd[0]））<br>管道在读取设备时，默认read是阻塞状态，read一直等待，并且直到write写入数据。</p>
<p>读管道：<br>    ○ 写端全部关闭—–read读到0，相当于读取到文件末尾<br>    ○ 写端没有关闭<br>        ○ 有数据—read正常读取数据<br>        ○ 没有数据—read阻塞 ，fcntl函数可以更改阻塞状态</p>
<p>写管道<br>    ○ 读端全部关闭—-产生一个信号，管道崩溃，程序异常终止<br>    ○ 读端未全部关闭<br>        ○ 管道已满（管道的本质就是一个缓冲区）—-写阻塞<br>        ○ 管道未满—-写端正常<br><img src="/2019/06/04/进程/pipe.png" alt="图片"><br>计算管道的大小size  ？kb*8<br><code>long fpathconf(int fd,int name)</code><br><code>ulimit -a</code></p>
<p>管道的优劣<br>只有一个函数（pipe）所以简单<br>但是只能用于有血缘关系的进程进行通信，父子进程之间相互通信时，需要创建两个管道（保证安全性所以管道都是单方向通信）</p>
<p>FIFO–有名管道—-实现无血缘关系进行通信<br>    • 本质是实现了一个管道的伪文件<br>    • Mkfifo name 创建伪文件命令</p>
<p>创建FIFO的函数<br><code>int mkfifo(const char *pathname, mode_t mode);</code></p>
<pre><code>    • 文件路径，权限位（0666）
//利用有名管道实现一个进程写入文件，另一个进程读取文件的操作
 #include &lt;unistd.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;sys/types.h&gt;
 #include&lt;sys/stat.h&gt;
 #inlcude &lt;string.h&gt;
//写入端
//前提是已经存在文件 ，不存在的话需要在mode中加入O_CREATE
 int main(int argc,char *argv[])
{
     if(argc != 2)//运行时没有指定文件
    { 
        printf(&quot;error\n&quot;);
         return -1;
    }

     int fd = open(argv[1],O_WDONLY);
     char buf[1024];

     int num = 0;
     while(1)
    {
         memset(buf,0,sizeof(buf));//设置默认数据，清空
         sprintf(buf,&quot;test  %03d&quot;,num++);//将测试数据写入缓冲区
         write(fd,buf,strlen(buf));//缓冲区数据写入文件中

         sleep(2);//休眠2S执行一次
    }
     close(fd);
     return 0;
}

//读取端，头文件同上，省略
//写入端
//前提是已经存在文件 ，不存在的话需要在mode中加入O_CREATE
 int main(int argc,char *argv[])
{
     if(argc != 2)//运行时没有指定读取文件
    { 
        printf(&quot;error\n&quot;);
         return -1;
    }

     int fd = open(argv[1],O_RDONLY);
     char buf[1024];

     int temp;
     while(1)
    {
         temp = read(fd,buf,sizeof(buf));
         if(temp &gt;0)//文件中存在数据
        {
             printf(&quot;read data:%s\n&quot;,buf);
        }
    }
     close(fd);
     return 0;
}

</code></pre><hr>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/02/库/" rel="next" title="库">
                <i class="fa fa-chevron-left"></i> 库
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/19/线程/" rel="prev" title="线程">
                线程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Zurdo">
          <p class="site-author-name" itemprop="name">Zurdo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程"><span class="nav-number">1.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#程序"><span class="nav-number">1.1.</span> <span class="nav-text">程序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#定义"><span class="nav-number">1.1.1.</span> <span class="nav-text">定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的类型"><span class="nav-number">1.2.</span> <span class="nav-text">进程的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的状态"><span class="nav-number">1.3.</span> <span class="nav-text">进程的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux中查看进程信息"><span class="nav-number">1.4.</span> <span class="nav-text">Linux中查看进程信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的相关命令"><span class="nav-number">1.5.</span> <span class="nav-text">进程的相关命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的相关函数"><span class="nav-number">2.</span> <span class="nav-text">进程的相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#父子进程"><span class="nav-number">2.1.</span> <span class="nav-text">父子进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的返回值和结束方式"><span class="nav-number">2.2.</span> <span class="nav-text">进程的返回值和结束方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程创建-fork"><span class="nav-number">2.3.</span> <span class="nav-text">进程创建 - fork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程结束-exit-exit"><span class="nav-number">2.4.</span> <span class="nav-text">进程结束 - exit/_exit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程-exec函数族"><span class="nav-number">2.5.</span> <span class="nav-text">进程 - exec函数族</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程回收-wait"><span class="nav-number">2.6.</span> <span class="nav-text">进程回收 - wait</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程回收-waitpid-指定进程回收"><span class="nav-number">2.7.</span> <span class="nav-text">进程回收 - waitpid (指定进程回收)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#守护进程"><span class="nav-number">3.</span> <span class="nav-text">守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#守护进程的创建"><span class="nav-number">3.1.</span> <span class="nav-text">守护进程的创建</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程间通信"><span class="nav-number">4.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ipc通信的方式"><span class="nav-number">4.1.</span> <span class="nav-text">ipc通信的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#无名管道（半双工通信）"><span class="nav-number">4.1.1.</span> <span class="nav-text">无名管道（半双工通信）</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zurdo</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  

  


</body>
</html>
<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>